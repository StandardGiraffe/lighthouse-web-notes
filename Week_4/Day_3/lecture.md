# Lecture: Midterm Planning

We're now working in teams.  The ONLY thing we need to worry about from now until 11:00 am on Monday is this probject.

Project is designed to push us, and we will feel pressed for time.  (Try not to do an all-nighter on Sunday night.)  No lecture on Monday--just demos--then, in the afternoon, there's a careers services presentation.  Following that is a reading week for Computer Science and catchup.  (Don't go into Week 5 assuming it's a break---there's a full docket of reading.)

## Midterm

Pick a project: evaluate complexity, demands, and our comfort/interest.  Where do we start?

### Data Model:
What's everything we need to know about the problem?  (READ THE SPECS for the use-cases.)  Discuss this and build a vocabulary to reference the points.
* What is the data yo ucan access or acquire?
* Can you correlate the data to something else?
* _How can you pivot that data to add value?_
Try to draft the ERD with scratch notes that everyone can reference.


### Features vs. Benefits
Plan out features; Juan suggests we be lightweight when documenting features.

Features might employ _user stories_ to describe units of functionality.
"As a <blank>, I want to <blank> because <blank>."
"As a <blank>, I should be able to <blank> because <blank>."
Who is going to do what, why?

Learn to define nice-to-haves vs. core functionality (without which the app does not really exist).
Don't be discouraged by the size of your list/use case.  List as many as you can imagine, and prioritize:

**Universal Values**: Look good, feel good, save time, save money.

## Feature complete:
What is the Minimum Viable Product (MVP)?
Start with the simplest possible version of our design, and then add on as we nail them.  Then: what's the next priority/feature set?
Decide on your A-HA Moment: that moment of delight when the user understands why they need the system, and turns them from skeptics to advocates.  Could be the right messaging, the confirmation.

This project is about the demo.  **If it's not in the demo, don't spend time implementing it.**
Think about the flow so that there are no features isolated from each other.  The demo will show one path that highlights our whole flow.

## ERDs
Tables are the nouns, routes are the verbs

## Routes
Spend the first few hours planning the domain model and routes (RESTful design).  Figure out the interfaces between layers (routes, font-end, database, server) and use these as domains for work.

You could use a very vague wireframe of the front-end to help us establish routes and functions (rather than elaborating on the front-end design).

## Demo
Storyboard the demo.
Design matters, but we're developers rather than designers.  Use and draw from templates.

## Frameworks
Popular frameworks are Bootstrap and Foundation ZURB

## GIT (Team dynamics)
Good practices:
1.  Clone
2.  Branch
3.  Code! *TEST
4.  Checkout master
5.  Pull *TEST
6.  Merge *TEST
7.  Push
8.  Repeat from Step 2
**DON'T CODE ON MASTER.  ONLY WORK ON BRANCHES TO KEEP THE PROJECT SAFE.**


Try to bring everyone together during merging of branches to see where everyone is, and understand how the project is shaping.

Strategies for dividing tasks:
Domains (database, server/routes, front-end)
Features (everyone works on everything, but in slices---front-end, server, and database.  Harder for merging, but everyone understands the whole project better.)


Envision the feature (and the success state), and code towards that state.

## Team communication:
Establish expectations, rhythms.  Don't disappear.  Have an immediate way to reach each other (Slack, phone, etc.).  Could try Trello for task management.

Every day, evaluate your current plan, how you're moving, and redesign the plan when needed.

Have mentors present during planning sessions if possible.  Use mentors as normal for help.

**Have mentors review your foundational plans, like the ERD.**